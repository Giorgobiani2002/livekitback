import {
  AsyncIterableQueue,
  AudioByteStream,
  log,
  shortuuid,
  tokenize,
  tts
} from "@livekit/agents";
import { URL } from "node:url";
import { WebSocket } from "ws";
const DEFAULT_INACTIVITY_TIMEOUT = 300;
const DEFAULT_VOICE = {
  id: "bIHbv24MWmeRgasZH58o",
  name: "Bella",
  category: "premade",
  settings: {
    stability: 0.71,
    similarity_boost: 0.5,
    style: 0,
    use_speaker_boost: true
  }
};
const API_BASE_URL_V1 = "https://api.elevenlabs.io/v1/";
const AUTHORIZATION_HEADER = "xi-api-key";
const defaultTTSOptions = {
  apiKey: process.env.ELEVEN_API_KEY,
  voice: DEFAULT_VOICE,
  modelID: "eleven_turbo_v2_5",
  baseURL: API_BASE_URL_V1,
  encoding: "pcm_22050",
  wordTokenizer: new tokenize.basic.WordTokenizer(false),
  enableSsmlParsing: false,
  inactivityTimeout: DEFAULT_INACTIVITY_TIMEOUT,
  syncAlignment: true
};
class TTS extends tts.TTS {
  #opts;
  label = "elevenlabs.TTS";
  constructor(opts = {}) {
    super(sampleRateFromFormat(opts.encoding || defaultTTSOptions.encoding), 1, {
      streaming: true
    });
    this.#opts = {
      ...defaultTTSOptions,
      ...opts
    };
    if (this.#opts.apiKey === void 0) {
      throw new Error(
        "ElevenLabs API key is required, whether as an argument or as $ELEVEN_API_KEY"
      );
    }
  }
  async listVoices() {
    return fetch(this.#opts.baseURL + "/voices", {
      headers: {
        [AUTHORIZATION_HEADER]: this.#opts.apiKey
      }
    }).then((data) => data.json()).then((data) => {
      const voices = [];
      for (const voice of data.voices) {
        voices.push({
          id: voice.voice_id,
          name: voice.name,
          category: voice.category,
          settings: void 0
        });
      }
      return voices;
    });
  }
  synthesize() {
    throw new Error("Chunked responses are not supported on ElevenLabs TTS");
  }
  stream() {
    return new SynthesizeStream(this, this.#opts);
  }
}
class SynthesizeStream extends tts.SynthesizeStream {
  #opts;
  #logger = log();
  label = "elevenlabs.SynthesizeStream";
  streamURL;
  constructor(tts2, opts) {
    super(tts2);
    this.#opts = opts;
    this.closed = false;
    const baseURL = opts.baseURL + (opts.baseURL.endsWith("/") ? "" : "/");
    this.streamURL = new URL(`text-to-speech/${opts.voice.id}/stream-input`, baseURL);
    const params = {
      model_id: opts.modelID,
      output_format: opts.encoding,
      enable_ssml_parsing: `${opts.enableSsmlParsing}`,
      sync_alignment: `${opts.syncAlignment}`,
      ...opts.autoMode !== void 0 && { auto_mode: `${opts.autoMode}` },
      ...opts.languageCode && { language_code: opts.languageCode },
      ...opts.inactivityTimeout && { inactivity_timeout: `${opts.inactivityTimeout}` },
      ...opts.streamingLatency && { optimize_streaming_latency: `${opts.streamingLatency}` }
    };
    Object.entries(params).forEach(([k, v]) => this.streamURL.searchParams.append(k, v));
    this.streamURL.protocol = this.streamURL.protocol.replace("http", "ws");
  }
  async run() {
    const segments = new AsyncIterableQueue();
    const tokenizeInput = async () => {
      let stream = null;
      for await (const text of this.input) {
        if (this.abortController.signal.aborted) {
          break;
        }
        if (text === SynthesizeStream.FLUSH_SENTINEL) {
          stream == null ? void 0 : stream.endInput();
          stream = null;
        } else {
          if (!stream) {
            stream = this.#opts.wordTokenizer.stream();
            segments.put(stream);
          }
          stream.pushText(text);
        }
      }
      segments.close();
    };
    const runStream = async () => {
      for await (const stream of segments) {
        if (this.abortController.signal.aborted) {
          break;
        }
        await this.#runWS(stream);
        this.queue.put(SynthesizeStream.END_OF_STREAM);
      }
    };
    await Promise.all([tokenizeInput(), runStream()]);
  }
  async #runWS(stream, maxRetry = 3) {
    let retries = 0;
    let ws;
    while (true) {
      ws = new WebSocket(this.streamURL, {
        headers: { [AUTHORIZATION_HEADER]: this.#opts.apiKey }
      });
      ws.on("error", (error) => {
        this.abortController.abort();
        this.#logger.error({ error }, "Error connecting to ElevenLabs");
      });
      try {
        await new Promise((resolve, reject) => {
          ws.on("open", resolve);
          ws.on("error", (error) => reject(error));
          ws.on("close", (code) => reject(`WebSocket returned ${code}`));
        });
        break;
      } catch (e) {
        if (retries >= maxRetry) {
          throw new Error(`failed to connect to ElevenLabs after ${retries} attempts: ${e}`);
        }
        const delay = Math.min(retries * 5, 5);
        retries++;
        this.#logger.warn(
          `failed to connect to ElevenLabs, retrying in ${delay} seconds: ${e} (${retries}/${maxRetry})`
        );
        await new Promise((resolve) => setTimeout(resolve, delay * 1e3));
      }
    }
    const requestId = shortuuid();
    const segmentId = shortuuid();
    ws.send(
      JSON.stringify({
        text: " ",
        voice_settings: this.#opts.voice.settings,
        ...this.#opts.chunkLengthSchedule && {
          generation_config: {
            chunk_length_schedule: this.#opts.chunkLengthSchedule
          }
        }
      })
    );
    let eosSent = false;
    const sendTask = async () => {
      let xmlContent = [];
      for await (const data of stream) {
        if (this.abortController.signal.aborted) {
          break;
        }
        let text = data.token;
        if (this.#opts.enableSsmlParsing && text.startsWith("<phoneme") || xmlContent.length) {
          xmlContent.push(text);
          if (text.indexOf("</phoneme>") !== -1) {
            text = xmlContent.join(" ");
            xmlContent = [];
          } else {
            continue;
          }
        }
        ws.send(JSON.stringify({ text: text + " " }));
      }
      if (xmlContent.length) {
        this.#logger.warn("ElevenLabs stream ended with incomplete XML content");
      }
      ws.send(JSON.stringify({ text: "" }));
      eosSent = true;
    };
    let lastFrame;
    const sendLastFrame = (segmentId2, final) => {
      if (lastFrame) {
        this.queue.put({ requestId, segmentId: segmentId2, frame: lastFrame, final });
        lastFrame = void 0;
      }
    };
    const listenTask = async () => {
      let finalReceived = false;
      const bstream = new AudioByteStream(sampleRateFromFormat(this.#opts.encoding), 1);
      while (!this.closed && !this.abortController.signal.aborted) {
        try {
          await new Promise((resolve, reject) => {
            ws.removeAllListeners();
            ws.on("message", (data) => resolve(data));
            ws.on("close", (code, reason) => {
              if (!eosSent) {
                this.#logger.error(`WebSocket closed with code ${code}: ${reason}`);
              }
              if (!finalReceived) {
                reject(new Error("WebSocket closed"));
              }
            });
          }).then((msg) => {
            const json = JSON.parse(msg.toString());
            if ("audio" in json && json.audio !== null) {
              const data = new Int8Array(Buffer.from(json.audio, "base64"));
              for (const frame of bstream.write(data)) {
                sendLastFrame(segmentId, false);
                lastFrame = frame;
              }
            } else if (json.isFinal) {
              finalReceived = true;
              for (const frame of bstream.flush()) {
                sendLastFrame(segmentId, false);
                lastFrame = frame;
              }
              sendLastFrame(segmentId, true);
              this.queue.put(SynthesizeStream.END_OF_STREAM);
              if (segmentId === requestId || this.abortController.signal.aborted) {
                ws.close();
                return;
              }
            }
          });
        } catch (err) {
          if (err instanceof Error && !err.message.includes("WebSocket closed")) {
            this.#logger.error({ err }, "Error in listenTask from ElevenLabs WebSocket");
          }
          break;
        }
      }
    };
    await Promise.all([sendTask(), listenTask()]);
  }
}
const sampleRateFromFormat = (encoding) => {
  return Number(encoding.split("_")[1]);
};
export {
  SynthesizeStream,
  TTS
};
//# sourceMappingURL=tts.js.map