{"version":3,"sources":["../src/tts.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport {\n  AsyncIterableQueue,\n  AudioByteStream,\n  log,\n  shortuuid,\n  tokenize,\n  tts,\n} from '@livekit/agents';\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { URL } from 'node:url';\nimport { type RawData, WebSocket } from 'ws';\nimport type { TTSEncoding, TTSModels } from './models.js';\n\nconst DEFAULT_INACTIVITY_TIMEOUT = 300;\n\ntype Voice = {\n  id: string;\n  name: string;\n  category: string;\n  settings?: VoiceSettings;\n};\n\ntype VoiceSettings = {\n  stability: number; // 0..1\n  similarity_boost: number; // 0..1\n  style?: number; // 0..1\n  use_speaker_boost: boolean;\n};\n\nconst DEFAULT_VOICE: Voice = {\n  id: 'bIHbv24MWmeRgasZH58o',\n  name: 'Bella',\n  category: 'premade',\n  settings: {\n    stability: 0.71,\n    similarity_boost: 0.5,\n    style: 0.0,\n    use_speaker_boost: true,\n  },\n};\n\nconst API_BASE_URL_V1 = 'https://api.elevenlabs.io/v1/';\nconst AUTHORIZATION_HEADER = 'xi-api-key';\n\nexport interface TTSOptions {\n  apiKey?: string;\n  voice: Voice;\n  modelID: TTSModels | string;\n  languageCode?: string;\n  baseURL: string;\n  encoding: TTSEncoding;\n  streamingLatency?: number;\n  wordTokenizer: tokenize.WordTokenizer;\n  chunkLengthSchedule?: number[];\n  enableSsmlParsing: boolean;\n  inactivityTimeout: number;\n  syncAlignment: boolean;\n  autoMode?: boolean;\n}\n\nconst defaultTTSOptions: TTSOptions = {\n  apiKey: process.env.ELEVEN_API_KEY,\n  voice: DEFAULT_VOICE,\n  modelID: 'eleven_turbo_v2_5',\n  baseURL: API_BASE_URL_V1,\n  encoding: 'pcm_22050',\n  wordTokenizer: new tokenize.basic.WordTokenizer(false),\n  enableSsmlParsing: false,\n  inactivityTimeout: DEFAULT_INACTIVITY_TIMEOUT,\n  syncAlignment: true,\n};\n\nexport class TTS extends tts.TTS {\n  #opts: TTSOptions;\n  label = 'elevenlabs.TTS';\n\n  constructor(opts: Partial<TTSOptions> = {}) {\n    super(sampleRateFromFormat(opts.encoding || defaultTTSOptions.encoding), 1, {\n      streaming: true,\n    });\n\n    this.#opts = {\n      ...defaultTTSOptions,\n      ...opts,\n    };\n\n    if (this.#opts.apiKey === undefined) {\n      throw new Error(\n        'ElevenLabs API key is required, whether as an argument or as $ELEVEN_API_KEY',\n      );\n    }\n  }\n\n  async listVoices(): Promise<Voice[]> {\n    return fetch(this.#opts.baseURL + '/voices', {\n      headers: {\n        [AUTHORIZATION_HEADER]: this.#opts.apiKey!,\n      },\n    })\n      .then((data) => data.json())\n      .then((data) => {\n        const voices: Voice[] = [];\n        for (const voice of (\n          data as { voices: { voice_id: string; name: string; category: string }[] }\n        ).voices) {\n          voices.push({\n            id: voice.voice_id,\n            name: voice.name,\n            category: voice.category,\n            settings: undefined,\n          });\n        }\n        return voices;\n      });\n  }\n\n  synthesize(): tts.ChunkedStream {\n    throw new Error('Chunked responses are not supported on ElevenLabs TTS');\n  }\n\n  stream(): tts.SynthesizeStream {\n    return new SynthesizeStream(this, this.#opts);\n  }\n}\n\nexport class SynthesizeStream extends tts.SynthesizeStream {\n  #opts: TTSOptions;\n  #logger = log();\n  label = 'elevenlabs.SynthesizeStream';\n  readonly streamURL: URL;\n\n  constructor(tts: TTS, opts: TTSOptions) {\n    super(tts);\n    this.#opts = opts;\n    this.closed = false;\n\n    // add trailing slash to URL if needed\n    const baseURL = opts.baseURL + (opts.baseURL.endsWith('/') ? '' : '/');\n\n    this.streamURL = new URL(`text-to-speech/${opts.voice.id}/stream-input`, baseURL);\n    const params = {\n      model_id: opts.modelID,\n      output_format: opts.encoding,\n      enable_ssml_parsing: `${opts.enableSsmlParsing}`,\n      sync_alignment: `${opts.syncAlignment}`,\n      ...(opts.autoMode !== undefined && { auto_mode: `${opts.autoMode}` }),\n      ...(opts.languageCode && { language_code: opts.languageCode }),\n      ...(opts.inactivityTimeout && { inactivity_timeout: `${opts.inactivityTimeout}` }),\n      ...(opts.streamingLatency && { optimize_streaming_latency: `${opts.streamingLatency}` }),\n    };\n    Object.entries(params).forEach(([k, v]) => this.streamURL.searchParams.append(k, v));\n    this.streamURL.protocol = this.streamURL.protocol.replace('http', 'ws');\n  }\n\n  protected async run() {\n    const segments = new AsyncIterableQueue<tokenize.WordStream>();\n\n    const tokenizeInput = async () => {\n      let stream: tokenize.WordStream | null = null;\n      for await (const text of this.input) {\n        if (this.abortController.signal.aborted) {\n          break;\n        }\n        if (text === SynthesizeStream.FLUSH_SENTINEL) {\n          stream?.endInput();\n          stream = null;\n        } else {\n          if (!stream) {\n            stream = this.#opts.wordTokenizer.stream();\n            segments.put(stream);\n          }\n          stream.pushText(text);\n        }\n      }\n      segments.close();\n    };\n\n    const runStream = async () => {\n      for await (const stream of segments) {\n        if (this.abortController.signal.aborted) {\n          break;\n        }\n        await this.#runWS(stream);\n        this.queue.put(SynthesizeStream.END_OF_STREAM);\n      }\n    };\n\n    await Promise.all([tokenizeInput(), runStream()]);\n  }\n\n  async #runWS(stream: tokenize.WordStream, maxRetry = 3) {\n    let retries = 0;\n    let ws: WebSocket;\n    while (true) {\n      ws = new WebSocket(this.streamURL, {\n        headers: { [AUTHORIZATION_HEADER]: this.#opts.apiKey },\n      });\n\n      ws.on('error', (error) => {\n        this.abortController.abort();\n        this.#logger.error({ error }, 'Error connecting to ElevenLabs');\n      });\n\n      try {\n        await new Promise((resolve, reject) => {\n          ws.on('open', resolve);\n          ws.on('error', (error) => reject(error));\n          ws.on('close', (code) => reject(`WebSocket returned ${code}`));\n        });\n        break;\n      } catch (e) {\n        if (retries >= maxRetry) {\n          throw new Error(`failed to connect to ElevenLabs after ${retries} attempts: ${e}`);\n        }\n\n        const delay = Math.min(retries * 5, 5);\n        retries++;\n\n        this.#logger.warn(\n          `failed to connect to ElevenLabs, retrying in ${delay} seconds: ${e} (${retries}/${maxRetry})`,\n        );\n        await new Promise((resolve) => setTimeout(resolve, delay * 1000));\n      }\n    }\n\n    const requestId = shortuuid();\n    const segmentId = shortuuid();\n\n    ws.send(\n      JSON.stringify({\n        text: ' ',\n        voice_settings: this.#opts.voice.settings,\n        ...(this.#opts.chunkLengthSchedule && {\n          generation_config: {\n            chunk_length_schedule: this.#opts.chunkLengthSchedule,\n          },\n        }),\n      }),\n    );\n    let eosSent = false;\n\n    const sendTask = async () => {\n      let xmlContent: string[] = [];\n      for await (const data of stream) {\n        if (this.abortController.signal.aborted) {\n          break;\n        }\n        let text = data.token;\n\n        if ((this.#opts.enableSsmlParsing && text.startsWith('<phoneme')) || xmlContent.length) {\n          xmlContent.push(text);\n          if (text.indexOf('</phoneme>') !== -1) {\n            text = xmlContent.join(' ');\n            xmlContent = [];\n          } else {\n            continue;\n          }\n        }\n\n        ws.send(JSON.stringify({ text: text + ' ' })); //  must always end with a space\n      }\n\n      if (xmlContent.length) {\n        this.#logger.warn('ElevenLabs stream ended with incomplete XML content');\n      }\n\n      // no more tokens, mark eos\n      ws.send(JSON.stringify({ text: '' }));\n      eosSent = true;\n    };\n\n    let lastFrame: AudioFrame | undefined;\n    const sendLastFrame = (segmentId: string, final: boolean) => {\n      if (lastFrame) {\n        this.queue.put({ requestId, segmentId, frame: lastFrame, final });\n        lastFrame = undefined;\n      }\n    };\n\n    const listenTask = async () => {\n      let finalReceived = false;\n      const bstream = new AudioByteStream(sampleRateFromFormat(this.#opts.encoding), 1);\n      while (!this.closed && !this.abortController.signal.aborted) {\n        try {\n          await new Promise<RawData>((resolve, reject) => {\n            ws.removeAllListeners();\n            ws.on('message', (data) => resolve(data));\n            ws.on('close', (code, reason) => {\n              if (!eosSent) {\n                this.#logger.error(`WebSocket closed with code ${code}: ${reason}`);\n              }\n              if (!finalReceived) {\n                reject(new Error('WebSocket closed'));\n              }\n            });\n          }).then((msg) => {\n            const json = JSON.parse(msg.toString());\n            // remove the \"audio\" field from the json object when printing\n            if ('audio' in json && json.audio !== null) {\n              const data = new Int8Array(Buffer.from(json.audio, 'base64'));\n              for (const frame of bstream.write(data)) {\n                sendLastFrame(segmentId, false);\n                lastFrame = frame;\n              }\n            } else if (json.isFinal) {\n              finalReceived = true;\n              for (const frame of bstream.flush()) {\n                sendLastFrame(segmentId, false);\n                lastFrame = frame;\n              }\n              sendLastFrame(segmentId, true);\n              this.queue.put(SynthesizeStream.END_OF_STREAM);\n\n              if (segmentId === requestId || this.abortController.signal.aborted) {\n                ws.close();\n                return;\n              }\n            }\n          });\n        } catch (err) {\n          // skip log error for normal websocket close\n          if (err instanceof Error && !err.message.includes('WebSocket closed')) {\n            this.#logger.error({ err }, 'Error in listenTask from ElevenLabs WebSocket');\n          }\n          break;\n        }\n      }\n    };\n\n    await Promise.all([sendTask(), listenTask()]);\n  }\n}\n\nconst sampleRateFromFormat = (encoding: TTSEncoding): number => {\n  return Number(encoding.split('_')[1]);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,oBAOO;AAEP,sBAAoB;AACpB,gBAAwC;AAGxC,MAAM,6BAA6B;AAgBnC,MAAM,gBAAuB;AAAA,EAC3B,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AAAA,IACR,WAAW;AAAA,IACX,kBAAkB;AAAA,IAClB,OAAO;AAAA,IACP,mBAAmB;AAAA,EACrB;AACF;AAEA,MAAM,kBAAkB;AACxB,MAAM,uBAAuB;AAkB7B,MAAM,oBAAgC;AAAA,EACpC,QAAQ,QAAQ,IAAI;AAAA,EACpB,OAAO;AAAA,EACP,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AAAA,EACV,eAAe,IAAI,uBAAS,MAAM,cAAc,KAAK;AAAA,EACrD,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,eAAe;AACjB;AAEO,MAAM,YAAY,kBAAI,IAAI;AAAA,EAC/B;AAAA,EACA,QAAQ;AAAA,EAER,YAAY,OAA4B,CAAC,GAAG;AAC1C,UAAM,qBAAqB,KAAK,YAAY,kBAAkB,QAAQ,GAAG,GAAG;AAAA,MAC1E,WAAW;AAAA,IACb,CAAC;AAED,SAAK,QAAQ;AAAA,MACX,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAEA,QAAI,KAAK,MAAM,WAAW,QAAW;AACnC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,aAA+B;AACnC,WAAO,MAAM,KAAK,MAAM,UAAU,WAAW;AAAA,MAC3C,SAAS;AAAA,QACP,CAAC,oBAAoB,GAAG,KAAK,MAAM;AAAA,MACrC;AAAA,IACF,CAAC,EACE,KAAK,CAAC,SAAS,KAAK,KAAK,CAAC,EAC1B,KAAK,CAAC,SAAS;AACd,YAAM,SAAkB,CAAC;AACzB,iBAAW,SACT,KACA,QAAQ;AACR,eAAO,KAAK;AAAA,UACV,IAAI,MAAM;AAAA,UACV,MAAM,MAAM;AAAA,UACZ,UAAU,MAAM;AAAA,UAChB,UAAU;AAAA,QACZ,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACL;AAAA,EAEA,aAAgC;AAC9B,UAAM,IAAI,MAAM,uDAAuD;AAAA,EACzE;AAAA,EAEA,SAA+B;AAC7B,WAAO,IAAI,iBAAiB,MAAM,KAAK,KAAK;AAAA,EAC9C;AACF;AAEO,MAAM,yBAAyB,kBAAI,iBAAiB;AAAA,EACzD;AAAA,EACA,cAAU,mBAAI;AAAA,EACd,QAAQ;AAAA,EACC;AAAA,EAET,YAAYA,MAAU,MAAkB;AACtC,UAAMA,IAAG;AACT,SAAK,QAAQ;AACb,SAAK,SAAS;AAGd,UAAM,UAAU,KAAK,WAAW,KAAK,QAAQ,SAAS,GAAG,IAAI,KAAK;AAElE,SAAK,YAAY,IAAI,oBAAI,kBAAkB,KAAK,MAAM,EAAE,iBAAiB,OAAO;AAChF,UAAM,SAAS;AAAA,MACb,UAAU,KAAK;AAAA,MACf,eAAe,KAAK;AAAA,MACpB,qBAAqB,GAAG,KAAK,iBAAiB;AAAA,MAC9C,gBAAgB,GAAG,KAAK,aAAa;AAAA,MACrC,GAAI,KAAK,aAAa,UAAa,EAAE,WAAW,GAAG,KAAK,QAAQ,GAAG;AAAA,MACnE,GAAI,KAAK,gBAAgB,EAAE,eAAe,KAAK,aAAa;AAAA,MAC5D,GAAI,KAAK,qBAAqB,EAAE,oBAAoB,GAAG,KAAK,iBAAiB,GAAG;AAAA,MAChF,GAAI,KAAK,oBAAoB,EAAE,4BAA4B,GAAG,KAAK,gBAAgB,GAAG;AAAA,IACxF;AACA,WAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM,KAAK,UAAU,aAAa,OAAO,GAAG,CAAC,CAAC;AACnF,SAAK,UAAU,WAAW,KAAK,UAAU,SAAS,QAAQ,QAAQ,IAAI;AAAA,EACxE;AAAA,EAEA,MAAgB,MAAM;AACpB,UAAM,WAAW,IAAI,iCAAwC;AAE7D,UAAM,gBAAgB,YAAY;AAChC,UAAI,SAAqC;AACzC,uBAAiB,QAAQ,KAAK,OAAO;AACnC,YAAI,KAAK,gBAAgB,OAAO,SAAS;AACvC;AAAA,QACF;AACA,YAAI,SAAS,iBAAiB,gBAAgB;AAC5C,2CAAQ;AACR,mBAAS;AAAA,QACX,OAAO;AACL,cAAI,CAAC,QAAQ;AACX,qBAAS,KAAK,MAAM,cAAc,OAAO;AACzC,qBAAS,IAAI,MAAM;AAAA,UACrB;AACA,iBAAO,SAAS,IAAI;AAAA,QACtB;AAAA,MACF;AACA,eAAS,MAAM;AAAA,IACjB;AAEA,UAAM,YAAY,YAAY;AAC5B,uBAAiB,UAAU,UAAU;AACnC,YAAI,KAAK,gBAAgB,OAAO,SAAS;AACvC;AAAA,QACF;AACA,cAAM,KAAK,OAAO,MAAM;AACxB,aAAK,MAAM,IAAI,iBAAiB,aAAa;AAAA,MAC/C;AAAA,IACF;AAEA,UAAM,QAAQ,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,CAAC;AAAA,EAClD;AAAA,EAEA,MAAM,OAAO,QAA6B,WAAW,GAAG;AACtD,QAAI,UAAU;AACd,QAAI;AACJ,WAAO,MAAM;AACX,WAAK,IAAI,oBAAU,KAAK,WAAW;AAAA,QACjC,SAAS,EAAE,CAAC,oBAAoB,GAAG,KAAK,MAAM,OAAO;AAAA,MACvD,CAAC;AAED,SAAG,GAAG,SAAS,CAAC,UAAU;AACxB,aAAK,gBAAgB,MAAM;AAC3B,aAAK,QAAQ,MAAM,EAAE,MAAM,GAAG,gCAAgC;AAAA,MAChE,CAAC;AAED,UAAI;AACF,cAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AACrC,aAAG,GAAG,QAAQ,OAAO;AACrB,aAAG,GAAG,SAAS,CAAC,UAAU,OAAO,KAAK,CAAC;AACvC,aAAG,GAAG,SAAS,CAAC,SAAS,OAAO,sBAAsB,IAAI,EAAE,CAAC;AAAA,QAC/D,CAAC;AACD;AAAA,MACF,SAAS,GAAG;AACV,YAAI,WAAW,UAAU;AACvB,gBAAM,IAAI,MAAM,yCAAyC,OAAO,cAAc,CAAC,EAAE;AAAA,QACnF;AAEA,cAAM,QAAQ,KAAK,IAAI,UAAU,GAAG,CAAC;AACrC;AAEA,aAAK,QAAQ;AAAA,UACX,gDAAgD,KAAK,aAAa,CAAC,KAAK,OAAO,IAAI,QAAQ;AAAA,QAC7F;AACA,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,QAAQ,GAAI,CAAC;AAAA,MAClE;AAAA,IACF;AAEA,UAAM,gBAAY,yBAAU;AAC5B,UAAM,gBAAY,yBAAU;AAE5B,OAAG;AAAA,MACD,KAAK,UAAU;AAAA,QACb,MAAM;AAAA,QACN,gBAAgB,KAAK,MAAM,MAAM;AAAA,QACjC,GAAI,KAAK,MAAM,uBAAuB;AAAA,UACpC,mBAAmB;AAAA,YACjB,uBAAuB,KAAK,MAAM;AAAA,UACpC;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AACA,QAAI,UAAU;AAEd,UAAM,WAAW,YAAY;AAC3B,UAAI,aAAuB,CAAC;AAC5B,uBAAiB,QAAQ,QAAQ;AAC/B,YAAI,KAAK,gBAAgB,OAAO,SAAS;AACvC;AAAA,QACF;AACA,YAAI,OAAO,KAAK;AAEhB,YAAK,KAAK,MAAM,qBAAqB,KAAK,WAAW,UAAU,KAAM,WAAW,QAAQ;AACtF,qBAAW,KAAK,IAAI;AACpB,cAAI,KAAK,QAAQ,YAAY,MAAM,IAAI;AACrC,mBAAO,WAAW,KAAK,GAAG;AAC1B,yBAAa,CAAC;AAAA,UAChB,OAAO;AACL;AAAA,UACF;AAAA,QACF;AAEA,WAAG,KAAK,KAAK,UAAU,EAAE,MAAM,OAAO,IAAI,CAAC,CAAC;AAAA,MAC9C;AAEA,UAAI,WAAW,QAAQ;AACrB,aAAK,QAAQ,KAAK,qDAAqD;AAAA,MACzE;AAGA,SAAG,KAAK,KAAK,UAAU,EAAE,MAAM,GAAG,CAAC,CAAC;AACpC,gBAAU;AAAA,IACZ;AAEA,QAAI;AACJ,UAAM,gBAAgB,CAACC,YAAmB,UAAmB;AAC3D,UAAI,WAAW;AACb,aAAK,MAAM,IAAI,EAAE,WAAW,WAAAA,YAAW,OAAO,WAAW,MAAM,CAAC;AAChE,oBAAY;AAAA,MACd;AAAA,IACF;AAEA,UAAM,aAAa,YAAY;AAC7B,UAAI,gBAAgB;AACpB,YAAM,UAAU,IAAI,8BAAgB,qBAAqB,KAAK,MAAM,QAAQ,GAAG,CAAC;AAChF,aAAO,CAAC,KAAK,UAAU,CAAC,KAAK,gBAAgB,OAAO,SAAS;AAC3D,YAAI;AACF,gBAAM,IAAI,QAAiB,CAAC,SAAS,WAAW;AAC9C,eAAG,mBAAmB;AACtB,eAAG,GAAG,WAAW,CAAC,SAAS,QAAQ,IAAI,CAAC;AACxC,eAAG,GAAG,SAAS,CAAC,MAAM,WAAW;AAC/B,kBAAI,CAAC,SAAS;AACZ,qBAAK,QAAQ,MAAM,8BAA8B,IAAI,KAAK,MAAM,EAAE;AAAA,cACpE;AACA,kBAAI,CAAC,eAAe;AAClB,uBAAO,IAAI,MAAM,kBAAkB,CAAC;AAAA,cACtC;AAAA,YACF,CAAC;AAAA,UACH,CAAC,EAAE,KAAK,CAAC,QAAQ;AACf,kBAAM,OAAO,KAAK,MAAM,IAAI,SAAS,CAAC;AAEtC,gBAAI,WAAW,QAAQ,KAAK,UAAU,MAAM;AAC1C,oBAAM,OAAO,IAAI,UAAU,OAAO,KAAK,KAAK,OAAO,QAAQ,CAAC;AAC5D,yBAAW,SAAS,QAAQ,MAAM,IAAI,GAAG;AACvC,8BAAc,WAAW,KAAK;AAC9B,4BAAY;AAAA,cACd;AAAA,YACF,WAAW,KAAK,SAAS;AACvB,8BAAgB;AAChB,yBAAW,SAAS,QAAQ,MAAM,GAAG;AACnC,8BAAc,WAAW,KAAK;AAC9B,4BAAY;AAAA,cACd;AACA,4BAAc,WAAW,IAAI;AAC7B,mBAAK,MAAM,IAAI,iBAAiB,aAAa;AAE7C,kBAAI,cAAc,aAAa,KAAK,gBAAgB,OAAO,SAAS;AAClE,mBAAG,MAAM;AACT;AAAA,cACF;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH,SAAS,KAAK;AAEZ,cAAI,eAAe,SAAS,CAAC,IAAI,QAAQ,SAAS,kBAAkB,GAAG;AACrE,iBAAK,QAAQ,MAAM,EAAE,IAAI,GAAG,+CAA+C;AAAA,UAC7E;AACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,QAAQ,IAAI,CAAC,SAAS,GAAG,WAAW,CAAC,CAAC;AAAA,EAC9C;AACF;AAEA,MAAM,uBAAuB,CAAC,aAAkC;AAC9D,SAAO,OAAO,SAAS,MAAM,GAAG,EAAE,CAAC,CAAC;AACtC;","names":["tts","segmentId"]}